<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Jeu pédagogique BTP - Prototype 3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      background: #e6e6e6;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex; flex-direction: column; align-items: stretch;
    }
    header { padding: 12px 16px; font-weight: 600; }
    #viewer { flex: 1 1 auto; }
    #controls {
      padding: 10px 16px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      background: #f5f5f5; border-top: 1px solid #ddd;
    }
    button {
      padding: 10px 16px; font-size: 15px; cursor: pointer; background: #0078d7; color: #fff;
      border: none; border-radius: 8px;
    }
    button:hover { background: #005a9e; }
    .status { font-size: 14px; color: #333; }
  </style>
</head>
<body>
  <header>Construction pas à pas - BTP</header>
  <div id="viewer"></div>
  <div id="controls">
    <button id="prevStep">⬅ Étape précédente</button>
    <button id="nextStep">Étape suivante ➡</button>
    <span class="status" id="status">Prêt</span>
  </div>

  <!-- ES Modules depuis unpkg -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
    import { DRACOLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js";

    // --- Variables de base
    let scene, camera, renderer, controls;
    let currentStep = 1;
    const totalSteps = 8;
    let currentModel = null;
    const viewer = document.getElementById("viewer");
    const statusEl = document.getElementById("status");

    // --- Initialisation
    init();
    loadStep(currentStep);

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xe6e6e6);

      const rect = viewer.getBoundingClientRect();
      const aspect = rect.width / Math.max(1, rect.height || window.innerHeight * 0.7);
      camera = new THREE.PerspectiveCamera(50, aspect, 0.01, 2000);
      camera.position.set(6, 5, 9);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(rect.width, rect.height || window.innerHeight * 0.7);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      viewer.appendChild(renderer.domElement);

      // Lumières
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemi.position.set(0, 1, 0);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 10, 7);
      dir.castShadow = false;
      scene.add(dir);

      // Grille sol (facultatif)
      const grid = new THREE.GridHelper(50, 50, 0xaaaaaa, 0xdddddd);
      grid.material.opacity = 0.35; grid.material.transparent = true;
      scene.add(grid);

      // Contrôles
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;

      window.addEventListener("resize", onResize);
      renderer.setAnimationLoop(() => {
        controls.update();
        renderer.render(scene, camera);
      });

      // Boutons
      document.getElementById("nextStep").addEventListener("click", () => {
        if (currentStep < totalSteps) {
          currentStep++;
          loadStep(currentStep);
        }
      });
      document.getElementById("prevStep").addEventListener("click", () => {
        if (currentStep > 1) {
          currentStep--;
          loadStep(currentStep);
        }
      });
    }

    function onResize() {
      const rect = viewer.getBoundingClientRect();
      const w = rect.width || window.innerWidth;
      const h = rect.height || Math.max(1, window.innerHeight * 0.7);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function loadStep(step) {
      const modelPath = `./models/etape${step}.glb`;
      setStatus(`Chargement : ${modelPath} …`);

      // Nettoyage modèle précédent
      if (currentModel) {
        scene.remove(currentModel);
        currentModel.traverse(o => {
          if (o.geometry) o.geometry.dispose();
          if (o.material) {
            if (Array.isArray(o.material)) o.material.forEach(m => m.dispose());
            else o.material.dispose();
          }
        });
        currentModel = null;
      }

      const loader = new GLTFLoader();

      // Support DRACO si vos .glb sont compressés
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/");
      loader.setDRACOLoader(dracoLoader);

      loader.load(
        modelPath,
        (gltf) => {
          currentModel = gltf.scene;
          scene.add(currentModel);

          // sRGB pour textures
          currentModel.traverse((obj) => {
            if (obj.isMesh && obj.material) {
              if (obj.material.map) obj.material.map.colorSpace = THREE.SRGBColorSpace;
              if (obj.material.emissiveMap) obj.material.emissiveMap.colorSpace = THREE.SRGBColorSpace;
            }
          });

          frameObject(currentModel);
          setStatus(`Affiché : ${modelPath} (étape ${step}/${totalSteps})`);
        },
        (xhr) => {
          const pct = xhr.total ? Math.round((xhr.loaded / xhr.total) * 100) : 0;
          setStatus(`Chargement : ${modelPath} ${pct}%`);
        },
        (err) => {
          console.error(`Erreur lors du chargement de ${modelPath}`, err);
          setStatus(`⚠️ Impossible de charger ${modelPath} (voir console). Vérifiez le nom et l'emplacement.`);
        }
      );
    }

    // --- Cadrage automatique de la caméra ---
    function frameObject(object3D) {
      const box = new THREE.Box3().setFromObject(object3D);
      if (box.isEmpty()) return;

      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      // Cible des contrôles = centre du modèle
      controls.target.copy(center);

      // Calcul d'une distance idéale en fonction de la taille max du modèle
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = THREE.MathUtils.degToRad(camera.fov); // en radians
      // distance pour faire rentrer la bounding-sphere dans le frustum vertical
      const distance = (maxDim / 2) / Math.tan(fov / 2) * 1.3; // marge 30%

      // Direction de vue oblique "3/4"
      const dir = new THREE.Vector3(1, 0.8, 1).normalize();
      camera.position.copy(center).addScaledVector(dir, distance);

      // Plans de clipping adaptés
      camera.near = Math.max(0.01, maxDim / 1000);
      camera.far = distance * 10;
      camera.updateProjectionMatrix();
      controls.update();
    }
  </script>
</body>
</html>
